//! autogenerated by v_escape_codegen@0.1.9
static V_ESCAPE_CHARS: [u8; 256] = [
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 0u8, 1u8, 2u8, 3u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 4u8, 10u8, 5u8, 6u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 7u8, 10u8, 8u8, 9u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
    10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8, 10u8,
];
static V_ESCAPE_QUOTES: [&str; 10usize] = [
    "\\#",
    "\\$",
    "\\%",
    "\\&",
    "\\textbackslash{}",
    "\\textasciicircum{}",
    "\\_",
    "\\{",
    "\\}",
    "\\textasciitilde{}",
];
const V_ESCAPE_LEN: usize = 10usize;
use v_escape_base::{Escapes, EscapesBuilder, Vector, escape_builder};
#[derive(Debug, Clone, Copy)]
struct Escape<V: Vector> {
    translation_a: V,
    below_a: V,
    translation_b: V,
    below_b: V,
    translation_c: V,
    below_c: V,
}
#[allow(dead_code)]
struct Builder;
impl EscapesBuilder for Builder {
    type Escapes<V: Vector> = Escape<V>;
    fn new<V: Vector>() -> Self::Escapes<V> {
        Self::Escapes {
            translation_a: V::splat(89i8 as u8),
            below_a: V::splat(123i8 as u8),
            translation_b: V::splat(32i8 as u8),
            below_b: V::splat(123i8 as u8),
            translation_c: V::splat(1i8 as u8),
            below_c: V::splat(123i8 as u8),
        }
    }
}
impl<V: Vector> Escapes for Escape<V> {
    const ESCAPE_LEN: usize = 10usize;
    const FALSE_POSITIVE: bool = true;
    type Vector = V;
    #[inline(always)]
    fn masking(&self, vector2: V) -> V {
        vector2
            .add(self.translation_a)
            .gt(self.below_a)
            .or(vector2.add(self.translation_b).gt(self.below_b))
            .or(vector2.add(self.translation_c).gt(self.below_c))
    }
    #[inline(always)]
    fn escape(i: usize) -> &'static str {
        V_ESCAPE_QUOTES[i]
    }
    #[inline(always)]
    fn position(i: u8) -> usize {
        V_ESCAPE_CHARS[i as usize] as usize
    }
    #[inline(always)]
    fn byte_byte_compare(c: u8) -> bool {
        (V_ESCAPE_CHARS[c as usize] as usize) < V_ESCAPE_LEN
    }
}
escape_builder!(Builder);
