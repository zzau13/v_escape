//! autogenerated by v_escape_codegen@0.1.9
static V_ESCAPE_CHARS: [u8; 256] = [
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 0u8, 6u8, 6u8, 6u8,
    1u8, 2u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 3u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 4u8, 6u8, 5u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
    6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8, 6u8,
];
static V_ESCAPE_QUOTES: [&str; 6usize] = ["&quot;", "&amp;", "&#x27;", "&#x2f;", "&lt;", "&gt;"];
const V_ESCAPE_LEN: usize = 6usize;
use v_escape_base::{Escapes, EscapesBuilder, Vector, escape_builder};
#[derive(Debug, Clone, Copy)]
struct Escape<V: Vector> {
    translation_a: V,
    below_a: V,
    translation_b: V,
    below_b: V,
    c: V,
}
#[allow(dead_code)]
struct Builder;
impl EscapesBuilder for Builder {
    type Escapes<V: Vector> = Escape<V>;
    fn new<V: Vector>() -> Self::Escapes<V> {
        Self::Escapes {
            translation_a: V::splat(88i8 as u8),
            below_a: V::splat(121i8 as u8),
            translation_b: V::splat(65i8 as u8),
            below_b: V::splat(124i8 as u8),
            c: V::splat(47i8 as u8),
        }
    }
}
impl<V: Vector> Escapes for Escape<V> {
    const ESCAPE_LEN: usize = 6usize;
    const FALSE_POSITIVE: bool = true;
    type Vector = V;
    #[inline(always)]
    fn masking(&self, vector2: V) -> V {
        vector2
            .add(self.translation_a)
            .gt(self.below_a)
            .or(vector2.add(self.translation_b).gt(self.below_b))
            .or(vector2.cmpeq(self.c))
    }
    #[inline(always)]
    fn escape(i: usize) -> &'static str {
        V_ESCAPE_QUOTES[i]
    }
    #[inline(always)]
    fn position(i: u8) -> usize {
        V_ESCAPE_CHARS[i as usize] as usize
    }
    #[inline(always)]
    fn byte_byte_compare(c: u8) -> bool {
        (V_ESCAPE_CHARS[c as usize] as usize) < V_ESCAPE_LEN
    }
}
escape_builder!(Builder);
