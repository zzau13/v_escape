//! autogenerated by v_escape_codegen@0.1.9
static V_ESCAPE_CHARS: [u8; 256] = [
    0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8, 16u8,
    17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8, 30u8, 31u8, 34u8,
    34u8, 32u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 33u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
    34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8, 34u8,
];
static V_ESCAPE_QUOTES: [&str; 34usize] = [
    "\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b",
    "\\t", "\\n", "\\u000b", "\\f", "\\r", "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012",
    "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a",
    "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f", "\\\"", "\\\\",
];
const V_ESCAPE_LEN: usize = 34usize;
use v_escape_base::{Escapes, EscapesBuilder, Vector, escape_builder};
#[derive(Debug, Clone, Copy)]
struct Escape<V: Vector> {
    translation_a: V,
    below_a: V,
    b: V,
    c: V,
}
#[allow(dead_code)]
struct Builder;
impl EscapesBuilder for Builder {
    type Escapes<V: Vector> = Escape<V>;
    fn new<V: Vector>() -> Self::Escapes<V> {
        Self::Escapes {
            translation_a: V::splat(96i8 as u8),
            below_a: V::splat(95i8 as u8),
            b: V::splat(34i8 as u8),
            c: V::splat(92i8 as u8),
        }
    }
}
impl<V: Vector> Escapes for Escape<V> {
    const ESCAPE_LEN: usize = 34usize;
    const FALSE_POSITIVE: bool = true;
    type Vector = V;
    #[inline(always)]
    fn masking(&self, vector2: V) -> V {
        vector2
            .add(self.translation_a)
            .gt(self.below_a)
            .or(vector2.cmpeq(self.b))
            .or(vector2.cmpeq(self.c))
    }
    #[inline(always)]
    fn escape(i: usize) -> &'static str {
        V_ESCAPE_QUOTES[i]
    }
    #[inline(always)]
    fn position(i: u8) -> usize {
        V_ESCAPE_CHARS[i as usize] as usize
    }
    #[inline(always)]
    fn byte_byte_compare(c: u8) -> bool {
        (V_ESCAPE_CHARS[c as usize] as usize) < V_ESCAPE_LEN
    }
}
escape_builder!(Builder);
